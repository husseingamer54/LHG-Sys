const Discord = require('discord.js');
const client = new Discord.Client();
const prefix = 'L';

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});

 
 
 client.on('message',message =>{
    if(!message.channel.guild) return;
if(message.content =='^members')
var E2Mdax = new Discord.RichEmbed()

.setTitle('==========ðŸŒ·| Members info==========')
.addField('** Members countðŸ‘¥.:**',`__** [ ${message.guild.memberCount} ]**__`,true)
.addField('ðŸ“—|online',` ${message.guild.members.filter(m=>m.presence.status == 'online').size}`)
.addField('ðŸ““| offline',`${message.guild.members.filter(m=>m.presence.status == 'offline').size}`)
.setFooter(`Requested By | ${message.author.tag}`)
.addField('**==============**',true)
.setColor('RANDOM')
message.channel.send(E2Mdax); 
});
 
 
 
 
 client.on('message', message => {
    if(!message.channel.guild) return;
    if(message.content.startsWith('^ping')) {
        if (message.author.bot) return;
        if(!message.channel.guild) return;
        var Bping =`${Math.round(client.ping)}`
                const E1ping = new Discord.RichEmbed()
        .setTitle('Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€')
        .addField(`**BOT Ping Is** :__${Bping}ðŸ“¶__`,"Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€Ù€")
        .setFooter(`Requested by | ${message.author.tag}`)
        .setColor('RANDOM')
        message.channel.send(E1ping);
    }
});




client.on("message", message =>{
  let command = message.content.split(" ")[0].slice(prefix.length);
  let args = message.content.split(" ").slice(1);
  if(!message.content.startsWith(prefix)) return;
  if(message.author.bot) return;
  if(command === "welcome") {
      let welcomechann = args.join(" ");
      if(!message.member.hasPermission("ADMINISTRATOR")) return message.reply("You must have the **`ADMINISTRATOR`** permission!")
      if(!message.guild.me.hasPermission("ADMINISTRATOR")) return message.reply("I must have the **`ADMINISTRATOR`** permissions!")
      if(!message.member.guild.channels.find(x => x.name === welcomechann)) return message.reply("Usage: **`(channel name)`**");
      message.reply("Successfully applied welcome to **`" + welcomechann + "`**")
      WelcomeChannel[message.guild.id] = {
          guild: message.guild.name,
          channel: welcomechann
      }
      fs.writeFile("./welcomer.json", JSON.stringify(WelcomeChannel, null, 4), err => {
          if(err) throw err;
  });
}
});
client.on('guildMemberAdd', async function (Monster) {
  const WelcomeChannelMK =  Monster.guild.channels.find(mk => mk.name === WelcomeChannel[Monster.guild.id].channel);
  if(!WelcomeChannelMK) return;
  Monster.guild.fetchInvites().then(guildInvites => {
      const uses = guildInvites.find(codes => codes.uses);
      const UserInvited = client.users.get(uses.inviter.id);
            let itsMe = client.emojis.find(copy => copy.name === "diamondmk");
            var EmbedWelcome = new Discord.RichEmbed()
            .setDescription(`${itsMe} __**New Member Joined**__
            âž¤ Welcome <@${Monster.user.id}> To **${Monster.guild.name}**
            âž¤ You Are Nr: **${Monster.guild.memberCount}**
            âž¤ Invited By: <@${UserInvited.id}>`)
            .setColor('#383c41');
  const MKPIC = ['./imgs/w1.png'];
  let Image = Canvas.Image,
     CodesMK = new Canvas(400, 200),
     ctx = CodesMK.getContext('2d');
 fs.readFile(MKPIC, function (err, Background) {
     if (err) return console.log(err);
     let BG = Canvas.Image;
     let ground = new Image;
     ground.src = Background;
     ctx.drawImage(ground, 0, 0, 400, 200);
         let url = Monster.user.displayAvatarURL.endsWith(".webp") ? Monster.user.displayAvatarURL.slice(100) + ".png" : Monster.user.displayAvatarURL;
         jimp.read(url, (err, ava) => {
             if (err) return console.log(err);
             ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                 if (err) return console.log(err);
                  ctx.font = "bold 16px Arial";
                  ctx.fontSize = '20px';
                  ctx.fillStyle = "#f1f1f1";
                  ctx.textAlign = "center";
                  ctx.fillText(Monster.guild.name, 254, 67);
                  ctx.font = "bold 16px Arial";
                  ctx.fontSize = '20px';
                  ctx.fillStyle = "#f1f1f1";
                  ctx.textAlign = "center";
                  ctx.fillText(Monster.guild.memberCount, 338, 161);
                  ctx.font = "bold 16px Arial";
                  ctx.fontSize = '20px';
                  ctx.fillStyle = "#f1f1f1";
                  ctx.textAlign = "center";
                  ctx.fillText(Monster.user.username, 77, 183);
                  let Avatar = Canvas.Image;
                  let ava = new Avatar;
                  ava.src = buf;
                  ctx.beginPath();
                  ctx.arc(77, 101, 62, 0, Math.PI*2);
                  ctx.stroke();
                  ctx.clip();
                  ctx.drawImage(ava, 13, 38, 128, 126);
          WelcomeChannelMK.send({embed: EmbedWelcome, file: CodesMK.toBuffer()});
              })
          })
      });
  })
});

client.on('message', message => {
if (message.content.startsWith(prefix + 'help')) { /// This is The DMS Code Send The Help In DMS // Code By NotGucci
    let pages = [`**
-_-_-_-_-Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¹Ø§Ù…Ø©_-_-_-_-

${prefix}ping/Ø¹Ù„Ø´Ø§Ù† ØªØ¹Ø±Ù Ø³Ø±Ø¹Ø© Ø§Ù„Ù†Øª Ø­Ù‚Ù‚
${prefix}members info/Ø¹Ù„Ø´Ø§Ù† ØªØ¹Ø±Ù ÙƒÙ… Ø´Ø®Øµ Ø¨Ù„ Ø³ÙŠØ±ÙØ±  Ø§ÙˆÙ†Ù„Ø§ÙŠÙ† ÙˆØ§ÙˆÙÙ„Ø§ÙŠÙ†
---------------------------------------------------------
-_-_-_-_-Ø§ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø¯Ù…Ù†ÙŠØ©-_-_-_-_-_-

${prefix}bc/Ù„Ø£Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© ÙÙ„Ø®Ø§Øµ
**
   
`]


 client.on('message', message => {
if(message.author.bot) return;
if(message.channel.type === 'dm') return;
    if(message.content.startsWith(prefix + 'bc')) {
     let filter = m => m.author.id === message.author.id;
 
 let recembed = new Discord.RichEmbed()
 .setTitle(`${client.user.username}`)
 .setDescription(`
 -=-=-=-=-=-=-=-=-=-=
 ðŸŽ– Broadcast sends to a specific role without embed
 
 ðŸ… Broadcast sends to a specific role with embed
 
 ðŸ“­ Broadcast sends for all members with embed
 
 ðŸ“§ Broadcast sends for all members without embed
 
 ðŸ”µ Broadcast sends for online members only without embed
 
 ðŸ”· Broadcast sends for online members only with embed
 
 âŒ To Cancel the process
 -=-=-=-=-=-=-=-=-=-=
 `)
 
 message.channel.sendEmbed(recembed).then(msg => {
     msg.react('ðŸŽ–')
     .then(() => msg.react('ðŸ…'))
     .then(() => msg.react('ðŸ“­'))
     .then(() =>  msg.react('ðŸ“§'))
     .then(() => msg.react('ðŸ”µ'))
     .then(() => msg.react('ðŸ”·'))
     .then(() => msg.react('âŒ'))
 
 
             let embedmsgFilter = (reaction, user) => reaction.emoji.name === 'ðŸ“­' && user.id === message.author.id;
 
             let normalmsgFilter = (reaction, user) => reaction.emoji.name === 'ðŸ“§' && user.id === message.author.id;
 
             let cancelFilter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
 
             let onlyroleFilter = (reaction, user) => reaction.emoji.name === 'ðŸŽ–' && user.id === message.author.id;8
 
             let onlineonlyFilter = (reaction, user) => reaction.emoji.name === 'ðŸ”µ' && user.id === message.author.id;8
 
             let embedonlineonlyFilter = (reaction, user) => reaction.emoji.name === 'ðŸ”·' && user.id === message.author.id;8
 
             let embedonlyroleFilter = (reaction, user) => reaction.emoji.name === 'ðŸ…' && user.id === message.author.id;8
 
             let embedmsg = msg.createReactionCollector(embedmsgFilter, { time: 0 });
 
             let normalmsg = msg.createReactionCollector(normalmsgFilter, { time: 0 });
     
             let onlyrole = msg.createReactionCollector(onlyroleFilter, { time: 0 });
 
             let embedonlyrole = msg.createReactionCollector(embedonlyroleFilter, { time: 0 });
 
             let onlineonly = msg.createReactionCollector(onlineonlyFilter, { time: 0 });
                 
             let embedonlineonly = msg.createReactionCollector(embedonlineonlyFilter, { time: 0 });
 
             let cancel = msg.createReactionCollector(cancelFilter, { time: 0 });
 
 embedonlineonly.on('collect', r => {
 
    let msge;
    message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
   
           message.channel.awaitMessages(filter, {
             max: 1,
             time: 90000,
             errors: ['time']
           })
           .then(collected => {
               collected.first().delete();
               msge = collected.first().content;
               msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
                 message.channel.awaitMessages(filter, {
                   max: 1,
                   time: 90000,
                   errors: ['time']
                 })
                 .then(collected => {
                   if(collected.first().content === 'yes') {
   message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
   
   
   message.guild.members.filter(m => m.presence.status === 'online').forEach(m => {
    var bc = new Discord.RichEmbed()
           .setColor('RANDOM')
           .setTitle(`:mega: New Broadcast`)
           .addField('ðŸ”°ServerðŸ”°', message.guild.name)
           .addField('ðŸš©SenderðŸš©', message.author.username)
           .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
           .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
           .setFooter(client.user.username, client.user.avatarURL);
           m.send({ embed: bc })
           m.send(`${m}`)
           
       })
   }})
   if(collected.first().content === 'no') {
   message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
   message.guild.members.filter(m => m.presence.status === 'online').forEach(m => {
    var bc = new Discord.RichEmbed()
           .setColor('RANDOM')
           .setTitle(`:mega: New Broadcast`)
           .addField('ðŸ”°ServerðŸ”°', message.guild.name)
           .addField('ðŸš©SenderðŸš©', message.author.username)
           .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
           .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
           .setFooter(client.user.username, client.user.avatarURL);
           m.send({ embed: bc })
           
       })
   }
                 
   })
               })
           })
       })
 
       
 onlineonly.on('collect', r => {
    let msge;
    message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
 
        message.channel.awaitMessages(filter, {
          max: 1,
          time: 90000,
          errors: ['time']
        })
        .then(collected => {
            collected.first().delete();
            msge = collected.first().content;
            msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
              message.channel.awaitMessages(filter, {
                max: 1,
                time: 90000,
                errors: ['time']
              })
              .then(collected => {
 
                if(collected.first().content === 'yes') {
message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
               
 
message.guild.members.filter(m => m.presence.status === 'online').forEach(m => {
    m.send(`${msge}`)
m.send(`${m}`)      
       
    })
}
if(collected.first().content === 'no') {
message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
message.guild.members.filter(m => m.presence.status === 'online').forEach(m => {
    m.send(`${msge}`)
               
    })}
})
})
        })
    })
})
 
 embedmsg.on('collect', r => {
     let msge;
  message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
 
         message.channel.awaitMessages(filter, {
           max: 1,
           time: 90000,
           errors: ['time']
         })
         .then(collected => {
             collected.first().delete();
             msge = collected.first().content;
             msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
               message.channel.awaitMessages(filter, {
                 max: 1,
                 time: 90000,
                 errors: ['time']
               })
               .then(collected => {
                 if(collected.first().content === 'yes') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
 
 
     message.guild.members.forEach(m => {
         var bc = new Discord.RichEmbed()
         .setColor('RANDOM')
         .setTitle(`:mega: New Broadcast`)
         .addField('ðŸ”°ServerðŸ”°', message.guild.name)
         .addField('ðŸš©SenderðŸš©', message.author.username)
         .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
         .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
         .setFooter(client.user.username, client.user.avatarURL);
         m.send({ embed: bc })
         m.send(`${m}`)
         
     })
 }})
 if(collected.first().content === 'no') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
     message.guild.members.forEach(m => {
         var bc = new Discord.RichEmbed()
         .setColor('RANDOM')
         .setTitle(`:mega: New Broadcast`)
         .addField('ðŸ”°ServerðŸ”°', message.guild.name)
         .addField('ðŸš©SenderðŸš©', message.author.username)
         .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
         .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
         .setFooter(client.user.username, client.user.avatarURL);
         m.send({ embed: bc })
         
     })
 }
               
 })
             })
         })
     })
 
 
   
 
 
 
 normalmsg.on('collect', r => {
     let msge;
     message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
 
         message.channel.awaitMessages(filter, {
           max: 1,
           time: 90000,
           errors: ['time']
         })
         .then(collected => {
             collected.first().delete();
             msge = collected.first().content;
             msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
               message.channel.awaitMessages(filter, {
                 max: 1,
                 time: 90000,
                 errors: ['time']
               })
               .then(collected => {
 
                 if(collected.first().content === 'yes') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
                 
 
     message.guild.members.forEach(m => {
 m.send(`${msge}`)
 m.send(`${m}`)      
         
     })
 }
 if(collected.first().content === 'no') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
     message.guild.members.forEach(m => {
         m.send(`${msge}`)
                 
     })}
 })
 })
         })
     })
 })
 
 onlyrole.on('collect', r => {
     let msge;
     let role;
     message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
 
         message.channel.awaitMessages(filter, {
           max: 1,
           time: 90000,
           errors: ['time']
         })
 
         .then(collected => {
             collected.first().delete();
             msge = collected.first().content;
                 msg.edit('âœ… **| Now Please Write The Role Name**').then(msg => {
                 message.channel.awaitMessages(filter, {
                     max: 1,
                     time: 90000,
                     errors: ['time']
                   })
         
         .then(collected => {
             collected.first().delete();
             role = collected.first().content;
                 let rolecheak = message.guild.roles.find('name', `${role}`)
             msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
               message.channel.awaitMessages(filter, {
                 max: 1,
                 time: 90000,
                 errors: ['time']
               })
               .then(collected => {
 
                 if(collected.first().content === 'yes') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
                 
 
             message.guild.members.filter(m => m.roles.get(rolecheak.id)).forEach(m => {
 
 m.send(`${msge}`)
 m.send(`${m}`)      
         
     })
 }
 if(collected.first().content === 'no') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
         message.guild.members.filter(m => m.roles.get(rolecheak.id)).forEach(m => {
 
         m.send(`${msge}`)
                 
     })}
 })
 })
         })
     })
 })
 })
 });
 
 
 
 embedonlyrole.on('collect', r => {
     let msge;
     let role;
     message.channel.send(':pencil: **| Please Write Now The Message To Send :pencil2: **').then(msg => {
 
         message.channel.awaitMessages(filter, {
           max: 1,
           time: 90000,
           errors: ['time']
         })
 
         .then(collected => {
             collected.first().delete();
             msge = collected.first().content;
                 msg.edit('âœ… **| Now Please Write The Role Name**').then(msg => {
                 message.channel.awaitMessages(filter, {
                     max: 1,
                     time: 90000,
                     errors: ['time']
                   })
         
         .then(collected => {
             collected.first().delete();
             role = collected.first().content;
                 let rolecheak = message.guild.roles.find('name', `${role}`)
             msg.edit('âœ… **| Do You Want A Mention In The Msg ? [yes OR no] **').then(msg => {
               message.channel.awaitMessages(filter, {
                 max: 1,
                 time: 90000,
                 errors: ['time']
               })
               .then(collected => {
 
                 if(collected.first().content === 'yes') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
                 
 
                     message.guild.members.filter(m => m.roles.get(rolecheak.id)).forEach(m => {
                         var bc = new Discord.RichEmbed()
         .setColor('RANDOM')
         .setTitle(`:mega: New Broadcast`)
         .addField('ðŸ”°ServerðŸ”°', message.guild.name)
         .addField('ðŸš©SenderðŸš©', message.author.username)
         .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
         .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
         .setFooter(client.user.username, client.user.avatarURL);
         m.send({ embed: bc })
 m.send(`${m}`)      
         
     })
 }
 if(collected.first().content === 'no') {
 message.channel.send(`**:white_check_mark: The Message Has Been Sent The Members :loudspeaker:**`);
 message.guild.members.filter(m => m.roles.get(rolecheak.id)).forEach(m => {
         var bc = new Discord.RichEmbed()
         .setColor('RANDOM')
         .setTitle(`:mega: New Broadcast`)
         .addField('ðŸ”°ServerðŸ”°', message.guild.name)
         .addField('ðŸš©SenderðŸš©', message.author.username)
         .addField('ðŸ“œMessageðŸ“œ', `${msge}`)
         .setThumbnail('https://a.top4top.net/p_1008gqyyd1.png')
         .setFooter(client.user.username, client.user.avatarURL);
         m.send({ embed: bc })
         
                 
     })}
 })
 })
         })
     })
 })
 })
 })
     cancel.on('collect', r => {
         let cancelembed = new Discord.RichEmbed()
         .setTitle('Successfully Canceled :x:')
      message.channel.sendEmbed(cancelembed)
         embedmsg.stop();
         normalmsg.stop();
         onlyrole.stop();
         embedonlyrole.stop();
         embedonlineonly.stop()
         onlineonly.stop()
         cancel.stop();
     })
 })
    }});
 
 
 
 
client.login('NTg5NzQ1MzI1MTY2ODIxMzc3.XQYJQw.kRVSakupuvGIKZJ6Wgn0LLTIwA4');
